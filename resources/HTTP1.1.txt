General Syntax: 
-----------------

	Status-Line: Contains the HTTP version, a space (SP), the status code, another space, and a reason phrase.
	The reason phrase is meant to be human readable and may vary, it doesn't have a set format.
	Example: HTTP/1.1 200 OK

	Header Fields: After the start-line come the headers. Each header field consists of a case-insensitive field name,
	followed by a colon (":"), and the field value. Field names are tokens.
	A sequence of lines each continues a preceding field-value is known as a header field continuation.
	Example: Content-Type: text/html

	Message Body: After the headers and an empty line, comes the optional message body.
	The "Content-Length" header field defines the length of the message body. In some cases,
	the "Transfer-Encoding" header field with a value of "chunked" might be used instead of "Content-Length".


URI (Uniform Resource Identifier)
----------------------------------

	Request Target: In an HTTP request, the URI of the resource being requested is included in the request-line as the "request target".
	In the most common form of HTTP request, the "origin form", this is just the path and query components of the URI. For example,
	in the request-line GET /hello.html HTTP/1.1, "/hello.html" is the request target.

	Absolute Form and Authority Form: HTTP/1.1 also supports the "absolute form" and "authority form" for the request target.
	The absolute form includes the scheme and authority components of the URI and is used when making requests to a proxy.
	The authority form includes only the authority component and is used with the CONNECT method.

	Asterisk Form: The "asterisk form" is a special form that includes just an asterisk ("*")
	and is used with the OPTIONS method to apply to the server as a whole.

	URI Encoding: URIs in HTTP/1.1 must be encoded as defined in RFC 3986.
	This includes percent-encoding certain reserved characters. For example,
	the space character is encoded as "%20".

	Host Header: When making an HTTP/1.1 request in the origin form or asterisk form,
	the client must include a "Host" header field in the request that includes the authority
	component of the target URI. For example: Host: www.example.com.

	Location and Content-Location Headers: The "Location" and "Content-Location" response header fields allow a server
	to refer the client to a different URI. The "Location" header is used in responses to tell the client where to go
	next (for example, after a 302 Found response), while the "Content-Location" header tells the client the location of the returned resource.



Connection Management
-------------------------

	Connection establishment: The client initiates an HTTP connection by establishing a TCP/IP connection to the server
	(usually on port 80 for HTTP or 443 for HTTPS). The process of establishing a TCP/IP connection is handled at a lower level
	(the transport layer) and is not part of the HTTP/1.1 specification per se.

	Persistent connections: HTTP/1.1 introduces the concept of persistent connections, which are also often called keep-alive connections.
	This means that by default, connections do not close after a single request/response cycle. Instead, they stay open, allowing multiple
	requests and responses to be sent over the same connection. This reduces the overhead of establishing a new connection for each request,
	particularly improving performance when loading a web page with many resources (like images, scripts, stylesheets).

	Pipelining: Along with persistent connections, HTTP/1.1 also introduces the concept of pipelining.
	This means that a client can send multiple requests without waiting for each response. However,
	responses must still be sent in the order the requests were received. In practice,
	pipelining is not widely used due to various complexities and compatibility issues.

	Connection closure: An HTTP/1.1 connection can be closed by either the client or the server.
	A client indicates that it will close the connection by including a "Connection: close" header in the request.
	A server indicates that it will close the connection by including a "Connection: close" header in the response.
	In both cases, the connection is closed after the response is sent. The server can also close the connection without
	a "Connection: close" header if it encounters an error or if it needs to free up resources.

	Message delimiting: In order to send multiple requests and responses over the same connection,
	HTTP/1.1 introduces a mechanism for delimiting messages. Each message consists of a start-line, headers,
	an empty line, and a body. The end of the headers is indicated by an empty line, and the length of the body
	is indicated by the "Content-Length" header or the "Transfer-Encoding: chunked" header.
	If neither of these headers is present, the message has no body, and the end of the message is the end of the headers.

	Proxy behavior: In the context of connections, proxies (intermediaries that forward requests and responses)
	are expected to maintain their own separate connections to clients and servers. This means that the closing
	of a connection on one side does not necessarily mean the closing of the connection on the other side


Message Routing
--------------------------


	HTTP/1.1 messages are typically routed from a client (the user agent) to a server (the origin server) that hosts
	the resource identified by the URI in the request. In some cases, the message might be routed through one or more intermediaries.
	Intermediaries can be categorized as proxies, gateways, and tunnels.

	Proxies: These are intermediaries that act on behalf of other clients. They forward the HTTP request and act as a relay for the response.
	The client will know if it is connecting through a proxy. Proxies are often used for their ability to cache responses or control access to the internet.

	Gateways: These are resources that act as an intermediary for a group of servers or other resources.
	When a gateway receives a request, it appears as if it is the original server for the requested resource.
	Clients may not know they are connecting through a gateway.

	Tunnels: These act as a relay point between two connections without changing the messages.
	They are typically established using the HTTP CONNECT method.

	The protocol supports these intermediaries and describes how messages should be forwarded, which headers should be modified, and how to handle errors.

	Here are the key points related to message routing:

	Via Header: This header field must be sent by a proxy or gateway to indicate the intermediaries that have processed the request or response.
	Each intermediary adds its own information to the Via field, so the field can provide a trace of the request/response route.

	Forwarded Header: The "Forwarded" header field is used by proxies to reveal the original information lost in forwarding, such as the original client's IP address.

	Request-URI/Effective Request URI: A proxy forwards the request-URI exactly as received.
	In the case of an absolute-form URI, the proxy must rewrite the request-target into origin-form before forwarding it.

	Max-Forwards Header: This header can be used with the OPTIONS and TRACE methods to limit the number of times a request is forwarded by proxies.
	If a proxy receives a request with a Max-Forwards value of zero, it must not forward the request,
	and instead, it should respond with a 200 (OK) status code and its own information.

	These rules help to facilitate the forwarding of HTTP/1.1 requests and responses through various network topologies,
	including those involving one or more proxies or gateways. By properly modifying and interpreting the HTTP header fields,
	each component involved can route HTTP traffic efficiently and accurately.


Message Forwarding
---------------------------

	Message Forwarding: A proxy must forward the received message towards the location indicated by the received Request-URI (request target).
	A proxy should not modify the request-line or response status line in any way.

	Header Fields Processing: A proxy must not modify the semantics of request and response header fields unless
	the modifications are explicitly required by the specification. For instance, "Connection" header field,
	"Host" header field, "Content-Length" etc. have explicit rules defined in RFC 7230.

	Payload Body Length: One of the challenges in forwarding HTTP messages is determining the length of the message body.
	If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the proxy
	must remove the Content-Length field prior to forwarding the message.

	Transfer Codings: Intermediaries can apply or remove transfer codings, such as chunked encoding, to the message body.
	If a message is received with the "chunked" transfer coding, it must be decoded before forwarding.

	TE Header Field: The TE (Transfer Encoding) request-header field indicates what extension transfer-codings,
	besides chunked, the client is willing to accept in response, and whether or not the client is willing to accept trailer fields in a chunked transfer-coding.

	End-to-End and Hop-by-Hop Headers: Headers in HTTP/1.1 are classified as either end-to-end or hop-by-hop.
	End-to-end headers must be transmitted to the final recipient of the message, while hop-by-hop headers are
	only relevant for the single transport-level connection over which they were transmitted.
	The "Connection" header field lists the hop-by-hop headers for that specific message.

	Trailers: HTTP/1.1 allows optional headers (trailers) to be sent after the message body in chunked transfer encoding.
	Intermediaries must either forward trailers untouched or discard them if they choose not to forward them.


Caching and HEAD responses
------------------------------

	Caching: HTTP/1.1 supports caching to improve performance by reducing the need to send full responses.
	Instead, a cached response can be used if the server indicates that it's allowable. Caching can be implemented in various parts of the network,
	including the client (web browser), origin server, or any intermediary such as a proxy server.

	Cache-Control Header: This header field is used to specify directives for caching mechanisms in both requests and responses.
	These directives control who can cache the response, under what circumstances, and for how long.
	Examples include "no-cache", "private", "max-age", etc.

	Validation: To ensure that the cache does not become stale, clients and proxies can use conditional requests to check whether the copy they hold is still valid.
	These usually involve the "If-Modified-Since" or "If-None-Match" headers. The server then returns a "304 Not Modified"
	status if the cached copy is still valid, which means a lot less data needs to be transmitted.

	Vary Header: The "Vary" header field is used by the server to signal which request headers might
	influence the response (and should thus be taken into account by caches). For example,
	a response might vary depending on the "Accept-Language" header in the request.

	HEAD Responses: The HEAD method is identical to GET except that the server must not send a message body in the response (i.e., the response terminates at the end of the header section).
	This is used when a client wishes to check for a valid resource or to see the headers that a GET response would include,
	such as checking the "Last-Modified" date or "Content-Length", without actually downloading the resource.

	When a server receives a HEAD request, it should respond as though the method were GET, except without a message body.
	This includes sending any corresponding headers such as "Content-Length", "Content-Type", "ETag", etc.

	The primary use case of the HEAD method is for validating hyperlinks and performing bandwidth-efficient resource updates (cache validation).

